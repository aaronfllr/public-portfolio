/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unxhr";
exports.ids = ["vendor-chunks/unxhr"];
exports.modules = {

/***/ "(rsc)/./node_modules/unxhr/lib/XMLHttpRequest.js":
/*!**************************************************!*\
  !*** ./node_modules/unxhr/lib/XMLHttpRequest.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @contributor Guillaume Grossetie <ggrossetie@yuzutech.fr>\n * @contributor David Jencks <djencks@apache.org>\n * @license MIT\n */\nconst Url = __webpack_require__(/*! url */ \"url\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst ospath = __webpack_require__(/*! path */ \"path\")\n\n// 100 MB\nconst DEFAULT_MAX_BUFFER = 1000 * 1000 * 100\n\nexports.XMLHttpRequest = function () {\n  'use strict'\n\n  /**\n   * Private variables\n   */\n  const self = this\n  const http = __webpack_require__(/*! http */ \"http\")\n  const https = __webpack_require__(/*! https */ \"https\")\n\n  // Holds http.js objects\n  let request\n  let response\n\n  // Request settings\n  let settings = {}\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  let disableHeaderCheck = false\n\n  // Set some default headers\n  const defaultHeaders = {\n    'User-Agent': 'node-XMLHttpRequest',\n    Accept: '*/*'\n  }\n\n  let headers = {}\n  const headersCase = {}\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  const forbiddenRequestHeaders = [\n    'accept-charset',\n    'accept-encoding',\n    'access-control-request-headers',\n    'access-control-request-method',\n    'connection',\n    'content-length',\n    'content-transfer-encoding',\n    'cookie',\n    'cookie2',\n    'date',\n    'expect',\n    'host',\n    'keep-alive',\n    'origin',\n    'referer',\n    'te',\n    'trailer',\n    'transfer-encoding',\n    'upgrade',\n    'via'\n  ]\n\n  // These request methods are not allowed\n  const forbiddenRequestMethods = [\n    'TRACE',\n    'TRACK',\n    'CONNECT'\n  ]\n\n  // Send flag\n  let sendFlag = false\n  // Error flag, used when errors occur or abort is called\n  let errorFlag = false\n\n  // Binary response (chunk)\n  const responseBinary = []\n\n  // Event listeners\n  const listeners = {}\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0\n  this.OPENED = 1\n  this.HEADERS_RECEIVED = 2\n  this.LOADING = 3\n  this.DONE = 4\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null\n\n  // Result & response\n  this.responseText = ''\n  this.responseXML = ''\n  this.status = null\n  this.statusText = null\n\n  // Whether cross-site Access-Control requests should be made using\n  // credentials such as cookies or authorization headers\n  this.withCredentials = false\n  // \"text\", \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\n  // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\n  // Omitting, '', or \"text\" will return a String.\n  // Other values will return an ArrayBuffer.\n  this.responseType = ''\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param header - {string} Header to validate\n   * @return {boolean} - False if not allowed, otherwise true\n   */\n  const isAllowedHttpHeader = function (header) {\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1)\n  }\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param method - {string}  Request method to validate\n   * @return {boolean} - False if not allowed, otherwise true\n   */\n  const isAllowedHttpMethod = function (method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1)\n  }\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param method - {string} Connection method (eg GET, POST)\n   * @param url - {string} URL for the connection.\n   * @param async - {boolean} Asynchronous connection. Default is true.\n   * @param [user] - {string} Username for basic authentication (optional)\n   * @param [password] - {string} Password for basic authentication (optional)\n   */\n  this.open = function (method, url, async, user, password) {\n    this.abort()\n    errorFlag = false\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error('SecurityError: Request method not allowed')\n    }\n\n    settings = {\n      method: method,\n      url: url.toString(),\n      async: (typeof async !== 'boolean' ? true : async),\n      user: user || null,\n      password: password || null\n    }\n\n    setState(this.OPENED)\n  }\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param state - {boolean} Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function (state) {\n    disableHeaderCheck = state\n  }\n\n  /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param header - {string} Header name\n   * @param value - {string} Header value\n   */\n  this.setRequestHeader = function (header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN')\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"')\n      return\n    }\n    if (sendFlag) {\n      throw new Error('INVALID_STATE_ERR: send flag is true')\n    }\n    header = headersCase[header.toLowerCase()] || header\n    headersCase[header.toLowerCase()] = header\n    headers[header] = headers[header] ? headers[header] + ', ' + value : value\n  }\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param header - {string} Name of header to get.\n   * @return {Object} - Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function (header) {\n    if (typeof header === 'string' &&\n      this.readyState > this.OPENED &&\n      response &&\n      response.headers &&\n      response.headers[header.toLowerCase()] &&\n      !errorFlag\n    ) {\n      return response.headers[header.toLowerCase()]\n    }\n\n    return null\n  }\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function () {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return ''\n    }\n    let result = ''\n\n    for (const i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== 'set-cookie' && i !== 'set-cookie2') {\n        result += i + ': ' + response.headers[i] + '\\r\\n'\n      }\n    }\n    return result.substr(0, result.length - 2)\n  }\n\n  /**\n   * Gets a request header\n   *\n   * @param name - {string} Name of header to get\n   * @return {string} Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function (name) {\n    if (typeof name === 'string' && headersCase[name.toLowerCase()]) {\n      return headers[headersCase[name.toLowerCase()]]\n    }\n\n    return ''\n  }\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param data - {string} Optional data to send as request body.\n   */\n  this.send = function (data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called')\n    }\n\n    if (sendFlag) {\n      throw new Error('INVALID_STATE_ERR: send has already been called')\n    }\n    let ssl = false\n    let local = false\n    const url = new Url.URL(settings.url)\n    let host\n    // Determine the server\n    switch (url.protocol) {\n      case 'https:':\n        ssl = true\n        host = url.hostname\n        break\n      case 'http:':\n        host = url.hostname\n        break\n      case 'file:':\n        local = true\n        break\n      case undefined:\n      case null:\n      case '':\n        host = 'localhost'\n        break\n      default:\n        throw new Error('Protocol not supported.')\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== 'GET') {\n        throw new Error('XMLHttpRequest: Only GET method is supported')\n      }\n      if (settings.async) {\n        fs.readFile(url, 'utf8', function (error, data) {\n          if (error) {\n            self.handleError(error, url)\n          } else {\n            self.status = 200\n            self.responseText = data\n            setState(self.DONE)\n          }\n        })\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url, 'utf8')\n          this.status = 200\n          setState(self.DONE)\n        } catch (e) {\n          this.handleError(e, url)\n        }\n      }\n\n      return\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    const port = url.port || (ssl ? 443 : 80)\n    // Add query string if one is used\n    const uri = url.pathname + (url.search ? url.search : '')\n\n    // Set the defaults if they haven't been set\n    for (const name in defaultHeaders) {\n      if (!headersCase[name.toLowerCase()]) {\n        headers[name] = defaultHeaders[name]\n      }\n    }\n\n    // Set the Host header or the server may reject the request\n    headers.Host = host\n    // IPv6 addresses must be escaped with brackets\n    if (url.host[0] === '[') {\n      headers.Host = '[' + headers.Host + ']'\n    }\n    if (!((ssl && port === 443) || port === 80)) {\n      headers.Host += ':' + url.port\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password === 'undefined') {\n        settings.password = ''\n      }\n      const authBuf = Buffer.from(settings.user + ':' + settings.password)\n      headers.Authorization = 'Basic ' + authBuf.toString('base64')\n    }\n\n    // Set content length header\n    if (settings.method === 'GET' || settings.method === 'HEAD') {\n      data = null\n    } else if (data) {\n      headers['Content-Length'] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)\n\n      if (!this.getRequestHeader('Content-Type')) {\n        headers['Content-Type'] = 'text/plain;charset=UTF-8'\n      }\n    } else if (settings.method === 'POST') {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers['Content-Length'] = 0\n    }\n\n    const options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: false,\n      withCredentials: self.withCredentials\n    }\n\n    const responseType = this.responseType || 'text'\n\n    // Reset error flag\n    errorFlag = false\n\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      const doRequest = ssl ? https.request : http.request\n\n      // Request is being sent, set send flag\n      sendFlag = true\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent('readystatechange')\n\n      // Handler for the response\n      const responseHandler = function responseHandler (resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp\n        // Check for redirect\n        // @TODO Prevent looped redirects\n        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location\n          const url = new Url.URL(settings.url)\n          // Set host var in case it's used later\n          host = url.hostname\n          // Options for the new request\n          const newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? 'GET' : settings.method,\n            headers: headers,\n            withCredentials: self.withCredentials\n          }\n\n          // Issue the new request\n          request = doRequest(newOptions, responseHandler).on('error', errorHandler)\n          request.end()\n          // @TODO Check if an XHR event needs to be fired here\n          return\n        }\n\n        const encoding = responseType === 'text' ? 'utf8' : 'binary'\n        if (encoding === 'utf8') {\n          response.setEncoding('utf8')\n        }\n\n        setState(self.HEADERS_RECEIVED)\n        self.status = response.statusCode\n\n        if (encoding === 'utf8') {\n          response.on('data', function (chunk) {\n            // Make sure there's some data\n            if (chunk) {\n              self.responseText += chunk\n            }\n            // Don't emit state changes if the connection has been aborted.\n            if (sendFlag) {\n              setState(self.LOADING)\n            }\n          })\n\n          response.on('end', function () {\n            if (sendFlag) {\n              // Discard the end event if the connection has been aborted\n              setState(self.DONE)\n              sendFlag = false\n            }\n          })\n        } else {\n          response.on('data', function (chunk) {\n            // Make sure there's some data\n            if (chunk) {\n              responseBinary.push(chunk)\n            }\n            // Don't emit state changes if the connection has been aborted.\n            if (sendFlag) {\n              setState(self.LOADING)\n            }\n          })\n\n          response.on('end', function () {\n            // buffers are Uint8Array instances\n            self.response = Buffer.concat(responseBinary).buffer\n            if (sendFlag) {\n              // Discard the end event if the connection has been aborted\n              setState(self.DONE)\n              sendFlag = false\n            }\n          })\n        }\n\n        response.on('error', function (error) {\n          self.handleError(error, url)\n        })\n      }\n\n      // Error handler for the request\n      const errorHandler = function errorHandler (error) {\n        self.handleError(error, url)\n      }\n\n      // Create the request\n      request = doRequest(options, responseHandler).on('error', errorHandler)\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data)\n      }\n\n      request.end()\n\n      self.dispatchEvent('loadstart')\n    } else { // Synchronous\n      const maxBuffer = process.env.UNXHR_MAX_BUFFER\n        ? parseInt(process.env.UNXHR_MAX_BUFFER)\n        : DEFAULT_MAX_BUFFER\n      const encoding = responseType === 'text' ? 'utf8' : 'binary'\n      const scriptPath = ospath.join(__dirname, 'request.js')\n      const output = (__webpack_require__(/*! child_process */ \"child_process\").execSync)(`\"${process.execPath}\" \"${scriptPath}\" \\\n--ssl=\"${ssl}\" \\\n--encoding=\"${encoding}\" \\\n--request-options=${JSON.stringify(JSON.stringify(options))}`, { stdio: ['pipe', 'pipe', 'pipe'], input: data, maxBuffer: maxBuffer })\n      const result = JSON.parse(output.toString('utf8'))\n      if (result.error) {\n        throw translateError(result.error, url)\n      } else {\n        response = result.data\n        self.status = result.data.statusCode\n        if (encoding === 'binary') {\n          self.response = Uint8Array.from(result.data.binary.data).buffer\n        } else {\n          self.responseText = result.data.text\n        }\n        setState(self.DONE)\n      }\n    }\n  }\n\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n  this.handleError = function (error, url) {\n    this.status = 0\n    this.statusText = ''\n    this.responseText = ''\n    errorFlag = true\n    setState(this.DONE)\n    this.dispatchEvent('error', { error: translateError(error, url) })\n  }\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function () {\n    if (request) {\n      request.abort()\n      request = null\n    }\n\n    headers = defaultHeaders\n    this.status = 0\n    this.responseText = ''\n    this.responseXML = ''\n\n    errorFlag = true\n\n    if (this.readyState !== this.UNSENT &&\n      (this.readyState !== this.OPENED || sendFlag) &&\n      this.readyState !== this.DONE) {\n      sendFlag = false\n      setState(this.DONE)\n    }\n    this.readyState = this.UNSENT\n    this.dispatchEvent('abort')\n  }\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function (event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = []\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback)\n  }\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function (event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function (ev) {\n        return ev !== callback\n      })\n    }\n  }\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function (event, args) {\n    if (typeof self['on' + event] === 'function') {\n      self['on' + event](args)\n    }\n    if (event in listeners) {\n      for (let i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self, args)\n      }\n    }\n  }\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param state - {Number} New state\n   */\n  const setState = function (state) {\n    if (state === self.LOADING || self.readyState !== state) {\n      self.readyState = state\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent('readystatechange')\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent('load')\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n        self.dispatchEvent('loadend')\n      }\n    }\n  }\n\n  const translateError = function (error, url) {\n    if (typeof error === 'object') {\n      if (error.code === 'ENOTFOUND' || error.code === 'EAI_AGAIN') {\n        // XMLHttpRequest throws a DOMException when DNS lookup fails:\n        // code: 19\n        // message: \"Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'http://url/'.\"\n        // name: \"NetworkError\"\n        // stack: (...)\n        return new Error(`Failed to execute 'send' on 'XMLHttpRequest': Failed to load '${url}'.`)\n      }\n      if (error instanceof Error) {\n        return error\n      }\n      return new Error(JSON.stringify(error))\n    }\n    return new Error(error)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW54aHIvbGliL1hNTEh0dHBSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLGtCQUFNOztBQUU3QjtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyxvQkFBTzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsU0FBUztBQUM5QixzQkFBc0IsUUFBUTtBQUM5QiwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUIscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFpQyxLQUFLLGlCQUFpQixLQUFLLFdBQVc7QUFDNUYsU0FBUyxJQUFJO0FBQ2IsY0FBYyxTQUFTO0FBQ3ZCLG9CQUFvQix3Q0FBd0MsS0FBSyxvRUFBb0U7QUFDckk7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUNBQW1DO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixJQUFJO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy91bnhoci9saWIvWE1MSHR0cFJlcXVlc3QuanM/YTliOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdyYXBwZXIgZm9yIGJ1aWx0LWluIGh0dHAuanMgdG8gZW11bGF0ZSB0aGUgYnJvd3NlciBYTUxIdHRwUmVxdWVzdCBvYmplY3QuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aXRoIEpTIGRlc2lnbmVkIGZvciBicm93c2VycyB0byBpbXByb3ZlIHJldXNlIG9mIGNvZGUgYW5kXG4gKiBhbGxvdyB0aGUgdXNlIG9mIGV4aXN0aW5nIGxpYnJhcmllcy5cbiAqXG4gKiBVc2FnZTogaW5jbHVkZShcIlhNTEh0dHBSZXF1ZXN0LmpzXCIpIGFuZCB1c2UgWE1MSHR0cFJlcXVlc3QgcGVyIFczQyBzcGVjcy5cbiAqXG4gKiBAYXV0aG9yIERhbiBEZUZlbGlwcGkgPGRhbkBkcml2ZXJkYW4uY29tPlxuICogQGNvbnRyaWJ1dG9yIERhdmlkIEVsbGlzIDxkLmYuZWxsaXNAaWVlZS5vcmc+XG4gKiBAY29udHJpYnV0b3IgR3VpbGxhdW1lIEdyb3NzZXRpZSA8Z2dyb3NzZXRpZUB5dXp1dGVjaC5mcj5cbiAqIEBjb250cmlidXRvciBEYXZpZCBKZW5ja3MgPGRqZW5ja3NAYXBhY2hlLm9yZz5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBvc3BhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gMTAwIE1CXG5jb25zdCBERUZBVUxUX01BWF9CVUZGRVIgPSAxMDAwICogMTAwMCAqIDEwMFxuXG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCdcblxuICAvKipcbiAgICogUHJpdmF0ZSB2YXJpYWJsZXNcbiAgICovXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJylcbiAgY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG5cbiAgLy8gSG9sZHMgaHR0cC5qcyBvYmplY3RzXG4gIGxldCByZXF1ZXN0XG4gIGxldCByZXNwb25zZVxuXG4gIC8vIFJlcXVlc3Qgc2V0dGluZ3NcbiAgbGV0IHNldHRpbmdzID0ge31cblxuICAvLyBEaXNhYmxlIGhlYWRlciBibGFja2xpc3QuXG4gIC8vIE5vdCBwYXJ0IG9mIFhIUiBzcGVjcy5cbiAgbGV0IGRpc2FibGVIZWFkZXJDaGVjayA9IGZhbHNlXG5cbiAgLy8gU2V0IHNvbWUgZGVmYXVsdCBoZWFkZXJzXG4gIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xuICAgICdVc2VyLUFnZW50JzogJ25vZGUtWE1MSHR0cFJlcXVlc3QnLFxuICAgIEFjY2VwdDogJyovKidcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0ge31cbiAgY29uc3QgaGVhZGVyc0Nhc2UgPSB7fVxuXG4gIC8vIFRoZXNlIGhlYWRlcnMgYXJlIG5vdCB1c2VyIHNldGFibGUuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbG93ZWQgYnV0IGJhbm5lZCBpbiB0aGUgc3BlYzpcbiAgLy8gKiB1c2VyLWFnZW50XG4gIGNvbnN0IGZvcmJpZGRlblJlcXVlc3RIZWFkZXJzID0gW1xuICAgICdhY2NlcHQtY2hhcnNldCcsXG4gICAgJ2FjY2VwdC1lbmNvZGluZycsXG4gICAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycycsXG4gICAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJyxcbiAgICAnY29ubmVjdGlvbicsXG4gICAgJ2NvbnRlbnQtbGVuZ3RoJyxcbiAgICAnY29udGVudC10cmFuc2Zlci1lbmNvZGluZycsXG4gICAgJ2Nvb2tpZScsXG4gICAgJ2Nvb2tpZTInLFxuICAgICdkYXRlJyxcbiAgICAnZXhwZWN0JyxcbiAgICAnaG9zdCcsXG4gICAgJ2tlZXAtYWxpdmUnLFxuICAgICdvcmlnaW4nLFxuICAgICdyZWZlcmVyJyxcbiAgICAndGUnLFxuICAgICd0cmFpbGVyJyxcbiAgICAndHJhbnNmZXItZW5jb2RpbmcnLFxuICAgICd1cGdyYWRlJyxcbiAgICAndmlhJ1xuICBdXG5cbiAgLy8gVGhlc2UgcmVxdWVzdCBtZXRob2RzIGFyZSBub3QgYWxsb3dlZFxuICBjb25zdCBmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcyA9IFtcbiAgICAnVFJBQ0UnLFxuICAgICdUUkFDSycsXG4gICAgJ0NPTk5FQ1QnXG4gIF1cblxuICAvLyBTZW5kIGZsYWdcbiAgbGV0IHNlbmRGbGFnID0gZmFsc2VcbiAgLy8gRXJyb3IgZmxhZywgdXNlZCB3aGVuIGVycm9ycyBvY2N1ciBvciBhYm9ydCBpcyBjYWxsZWRcbiAgbGV0IGVycm9yRmxhZyA9IGZhbHNlXG5cbiAgLy8gQmluYXJ5IHJlc3BvbnNlIChjaHVuaylcbiAgY29uc3QgcmVzcG9uc2VCaW5hcnkgPSBbXVxuXG4gIC8vIEV2ZW50IGxpc3RlbmVyc1xuICBjb25zdCBsaXN0ZW5lcnMgPSB7fVxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgdGhpcy5VTlNFTlQgPSAwXG4gIHRoaXMuT1BFTkVEID0gMVxuICB0aGlzLkhFQURFUlNfUkVDRUlWRUQgPSAyXG4gIHRoaXMuTE9BRElORyA9IDNcbiAgdGhpcy5ET05FID0gNFxuXG4gIC8qKlxuICAgKiBQdWJsaWMgdmFyc1xuICAgKi9cblxuICAvLyBDdXJyZW50IHN0YXRlXG4gIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuVU5TRU5UXG5cbiAgLy8gZGVmYXVsdCByZWFkeSBzdGF0ZSBjaGFuZ2UgaGFuZGxlciBpbiBjYXNlIG9uZSBpcyBub3Qgc2V0IG9yIGlzIHNldCBsYXRlXG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuXG4gIC8vIFJlc3VsdCAmIHJlc3BvbnNlXG4gIHRoaXMucmVzcG9uc2VUZXh0ID0gJydcbiAgdGhpcy5yZXNwb25zZVhNTCA9ICcnXG4gIHRoaXMuc3RhdHVzID0gbnVsbFxuICB0aGlzLnN0YXR1c1RleHQgPSBudWxsXG5cbiAgLy8gV2hldGhlciBjcm9zcy1zaXRlIEFjY2Vzcy1Db250cm9sIHJlcXVlc3RzIHNob3VsZCBiZSBtYWRlIHVzaW5nXG4gIC8vIGNyZWRlbnRpYWxzIHN1Y2ggYXMgY29va2llcyBvciBhdXRob3JpemF0aW9uIGhlYWRlcnNcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAvLyBcInRleHRcIiwgXCJhcnJheWJ1ZmZlclwiLCBcImJsb2JcIiwgb3IgXCJkb2N1bWVudFwiLCBkZXBlbmRpbmcgb24geW91ciBkYXRhIG5lZWRzLlxuICAvLyBOb3RlLCBzZXR0aW5nIHhoci5yZXNwb25zZVR5cGUgPSAnJyAob3Igb21pdHRpbmcpIHdpbGwgZGVmYXVsdCB0aGUgcmVzcG9uc2UgdG8gXCJ0ZXh0XCIuXG4gIC8vIE9taXR0aW5nLCAnJywgb3IgXCJ0ZXh0XCIgd2lsbCByZXR1cm4gYSBTdHJpbmcuXG4gIC8vIE90aGVyIHZhbHVlcyB3aWxsIHJldHVybiBhbiBBcnJheUJ1ZmZlci5cbiAgdGhpcy5yZXNwb25zZVR5cGUgPSAnJ1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZHNcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgaGVhZGVyIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBoZWFkZXIgLSB7c3RyaW5nfSBIZWFkZXIgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIGNvbnN0IGlzQWxsb3dlZEh0dHBIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgcmV0dXJuIGRpc2FibGVIZWFkZXJDaGVjayB8fCAoaGVhZGVyICYmIGZvcmJpZGRlblJlcXVlc3RIZWFkZXJzLmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIG1ldGhvZCBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0aG9kIC0ge3N0cmluZ30gIFJlcXVlc3QgbWV0aG9kIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gRmFsc2UgaWYgbm90IGFsbG93ZWQsIG90aGVyd2lzZSB0cnVlXG4gICAqL1xuICBjb25zdCBpc0FsbG93ZWRIdHRwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHJldHVybiAobWV0aG9kICYmIGZvcmJpZGRlblJlcXVlc3RNZXRob2RzLmluZGV4T2YobWV0aG9kKSA9PT0gLTEpXG4gIH1cblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZHNcbiAgICovXG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIGNvbm5lY3Rpb24uIEN1cnJlbnRseSBzdXBwb3J0cyBsb2NhbCBzZXJ2ZXIgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgLSB7c3RyaW5nfSBDb25uZWN0aW9uIG1ldGhvZCAoZWcgR0VULCBQT1NUKVxuICAgKiBAcGFyYW0gdXJsIC0ge3N0cmluZ30gVVJMIGZvciB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIGFzeW5jIC0ge2Jvb2xlYW59IEFzeW5jaHJvbm91cyBjb25uZWN0aW9uLiBEZWZhdWx0IGlzIHRydWUuXG4gICAqIEBwYXJhbSBbdXNlcl0gLSB7c3RyaW5nfSBVc2VybmFtZSBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gW3Bhc3N3b3JkXSAtIHtzdHJpbmd9IFBhc3N3b3JkIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvbiAob3B0aW9uYWwpXG4gICAqL1xuICB0aGlzLm9wZW4gPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xuICAgIHRoaXMuYWJvcnQoKVxuICAgIGVycm9yRmxhZyA9IGZhbHNlXG5cbiAgICAvLyBDaGVjayBmb3IgdmFsaWQgcmVxdWVzdCBtZXRob2RcbiAgICBpZiAoIWlzQWxsb3dlZEh0dHBNZXRob2QobWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBSZXF1ZXN0IG1ldGhvZCBub3QgYWxsb3dlZCcpXG4gICAgfVxuXG4gICAgc2V0dGluZ3MgPSB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLnRvU3RyaW5nKCksXG4gICAgICBhc3luYzogKHR5cGVvZiBhc3luYyAhPT0gJ2Jvb2xlYW4nID8gdHJ1ZSA6IGFzeW5jKSxcbiAgICAgIHVzZXI6IHVzZXIgfHwgbnVsbCxcbiAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCB8fCBudWxsXG4gICAgfVxuXG4gICAgc2V0U3RhdGUodGhpcy5PUEVORUQpXG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgb3IgZW5hYmxlcyBpc0FsbG93ZWRIdHRwSGVhZGVyKCkgY2hlY2sgdGhlIHJlcXVlc3QuIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogVGhpcyBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBXM0Mgc3BlYy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIC0ge2Jvb2xlYW59IEVuYWJsZSBvciBkaXNhYmxlIGhlYWRlciBjaGVja2luZy5cbiAgICovXG4gIHRoaXMuc2V0RGlzYWJsZUhlYWRlckNoZWNrID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgZGlzYWJsZUhlYWRlckNoZWNrID0gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgaGVhZGVyIGZvciB0aGUgcmVxdWVzdCBvciBhcHBlbmRzIHRoZSB2YWx1ZSBpZiBvbmUgaXMgYWxyZWFkeSBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBoZWFkZXIgLSB7c3RyaW5nfSBIZWFkZXIgbmFtZVxuICAgKiBAcGFyYW0gdmFsdWUgLSB7c3RyaW5nfSBIZWFkZXIgdmFsdWVcbiAgICovXG4gIHRoaXMuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9TVEFURV9FUlI6IHNldFJlcXVlc3RIZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gc3RhdGUgaXMgT1BFTicpXG4gICAgfVxuICAgIGlmICghaXNBbGxvd2VkSHR0cEhlYWRlcihoZWFkZXIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXCInICsgaGVhZGVyICsgJ1wiJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgZmxhZyBpcyB0cnVlJylcbiAgICB9XG4gICAgaGVhZGVyID0gaGVhZGVyc0Nhc2VbaGVhZGVyLnRvTG93ZXJDYXNlKCldIHx8IGhlYWRlclxuICAgIGhlYWRlcnNDYXNlW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlclxuICAgIGhlYWRlcnNbaGVhZGVyXSA9IGhlYWRlcnNbaGVhZGVyXSA/IGhlYWRlcnNbaGVhZGVyXSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSBoZWFkZXIgLSB7c3RyaW5nfSBOYW1lIG9mIGhlYWRlciB0byBnZXQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBUZXh0IG9mIHRoZSBoZWFkZXIgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgdGhpcy5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICBpZiAodHlwZW9mIGhlYWRlciA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA+IHRoaXMuT1BFTkVEICYmXG4gICAgICByZXNwb25zZSAmJlxuICAgICAgcmVzcG9uc2UuaGVhZGVycyAmJlxuICAgICAgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV0gJiZcbiAgICAgICFlcnJvckZsYWdcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAqXG4gICAqIEByZXR1cm4gc3RyaW5nIEEgc3RyaW5nIHdpdGggYWxsIHJlc3BvbnNlIGhlYWRlcnMgc2VwYXJhdGVkIGJ5IENSK0xGXG4gICAqL1xuICB0aGlzLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgdGhpcy5IRUFERVJTX1JFQ0VJVkVEIHx8IGVycm9yRmxhZykge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGxldCByZXN1bHQgPSAnJ1xuXG4gICAgZm9yIChjb25zdCBpIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIC8vIENvb2tpZSBoZWFkZXJzIGFyZSBleGNsdWRlZFxuICAgICAgaWYgKGkgIT09ICdzZXQtY29va2llJyAmJiBpICE9PSAnc2V0LWNvb2tpZTInKSB7XG4gICAgICAgIHJlc3VsdCArPSBpICsgJzogJyArIHJlc3BvbnNlLmhlYWRlcnNbaV0gKyAnXFxyXFxuJ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnN1YnN0cigwLCByZXN1bHQubGVuZ3RoIC0gMilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVxdWVzdCBoZWFkZXJcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB7c3RyaW5nfSBOYW1lIG9mIGhlYWRlciB0byBnZXRcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXF1ZXN0IGhlYWRlciBvciBlbXB0eSBzdHJpbmcgaWYgbm90IHNldFxuICAgKi9cbiAgdGhpcy5nZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIGhlYWRlcnNDYXNlW25hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgIHJldHVybiBoZWFkZXJzW2hlYWRlcnNDYXNlW25hbWUudG9Mb3dlckNhc2UoKV1dXG4gICAgfVxuXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgdGhlIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSB7c3RyaW5nfSBPcHRpb25hbCBkYXRhIHRvIHNlbmQgYXMgcmVxdWVzdCBib2R5LlxuICAgKi9cbiAgdGhpcy5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJTlZBTElEX1NUQVRFX0VSUjogY29ubmVjdGlvbiBtdXN0IGJlIG9wZW5lZCBiZWZvcmUgc2VuZCgpIGlzIGNhbGxlZCcpXG4gICAgfVxuXG4gICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVkFMSURfU1RBVEVfRVJSOiBzZW5kIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJylcbiAgICB9XG4gICAgbGV0IHNzbCA9IGZhbHNlXG4gICAgbGV0IGxvY2FsID0gZmFsc2VcbiAgICBjb25zdCB1cmwgPSBuZXcgVXJsLlVSTChzZXR0aW5ncy51cmwpXG4gICAgbGV0IGhvc3RcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNlcnZlclxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdodHRwczonOlxuICAgICAgICBzc2wgPSB0cnVlXG4gICAgICAgIGhvc3QgPSB1cmwuaG9zdG5hbWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2h0dHA6JzpcbiAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZmlsZTonOlxuICAgICAgICBsb2NhbCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgaG9zdCA9ICdsb2NhbGhvc3QnXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3RvY29sIG5vdCBzdXBwb3J0ZWQuJylcbiAgICB9XG5cbiAgICAvLyBMb2FkIGZpbGVzIG9mZiB0aGUgbG9jYWwgZmlsZXN5c3RlbSAoZmlsZTovLylcbiAgICBpZiAobG9jYWwpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MSHR0cFJlcXVlc3Q6IE9ubHkgR0VUIG1ldGhvZCBpcyBzdXBwb3J0ZWQnKVxuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAgIGZzLnJlYWRGaWxlKHVybCwgJ3V0ZjgnLCBmdW5jdGlvbiAoZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IsIHVybClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSAyMDBcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gZGF0YVxuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBmcy5yZWFkRmlsZVN5bmModXJsLCAndXRmOCcpXG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSAyMDBcbiAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUsIHVybClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHBvcnQgODAuIElmIGFjY2Vzc2luZyBsb2NhbGhvc3Qgb24gYW5vdGhlciBwb3J0IGJlIHN1cmVcbiAgICAvLyB0byB1c2UgaHR0cDovL2xvY2FsaG9zdDpwb3J0L3BhdGhcbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgfHwgKHNzbCA/IDQ0MyA6IDgwKVxuICAgIC8vIEFkZCBxdWVyeSBzdHJpbmcgaWYgb25lIGlzIHVzZWRcbiAgICBjb25zdCB1cmkgPSB1cmwucGF0aG5hbWUgKyAodXJsLnNlYXJjaCA/IHVybC5zZWFyY2ggOiAnJylcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgaWYgdGhleSBoYXZlbid0IGJlZW4gc2V0XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGRlZmF1bHRIZWFkZXJzKSB7XG4gICAgICBpZiAoIWhlYWRlcnNDYXNlW25hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgaGVhZGVyc1tuYW1lXSA9IGRlZmF1bHRIZWFkZXJzW25hbWVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBIb3N0IGhlYWRlciBvciB0aGUgc2VydmVyIG1heSByZWplY3QgdGhlIHJlcXVlc3RcbiAgICBoZWFkZXJzLkhvc3QgPSBob3N0XG4gICAgLy8gSVB2NiBhZGRyZXNzZXMgbXVzdCBiZSBlc2NhcGVkIHdpdGggYnJhY2tldHNcbiAgICBpZiAodXJsLmhvc3RbMF0gPT09ICdbJykge1xuICAgICAgaGVhZGVycy5Ib3N0ID0gJ1snICsgaGVhZGVycy5Ib3N0ICsgJ10nXG4gICAgfVxuICAgIGlmICghKChzc2wgJiYgcG9ydCA9PT0gNDQzKSB8fCBwb3J0ID09PSA4MCkpIHtcbiAgICAgIGhlYWRlcnMuSG9zdCArPSAnOicgKyB1cmwucG9ydFxuICAgIH1cblxuICAgIC8vIFNldCBCYXNpYyBBdXRoIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChzZXR0aW5ncy51c2VyKSB7XG4gICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZXR0aW5ncy5wYXNzd29yZCA9ICcnXG4gICAgICB9XG4gICAgICBjb25zdCBhdXRoQnVmID0gQnVmZmVyLmZyb20oc2V0dGluZ3MudXNlciArICc6JyArIHNldHRpbmdzLnBhc3N3b3JkKVxuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBhdXRoQnVmLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIH1cblxuICAgIC8vIFNldCBjb250ZW50IGxlbmd0aCBoZWFkZXJcbiAgICBpZiAoc2V0dGluZ3MubWV0aG9kID09PSAnR0VUJyB8fCBzZXR0aW5ncy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgZGF0YSA9IG51bGxcbiAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgPyBkYXRhLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpXG5cbiAgICAgIGlmICghdGhpcy5nZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnKSkge1xuICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgLy8gRm9yIGEgcG9zdCB3aXRoIG5vIGRhdGEgc2V0IENvbnRlbnQtTGVuZ3RoOiAwLlxuICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBieSBidWdneSBzZXJ2ZXJzIHRoYXQgZG9uJ3QgbWVldCB0aGUgc3BlY3MuXG4gICAgICBoZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gMFxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBob3N0OiBob3N0LFxuICAgICAgcG9ydDogcG9ydCxcbiAgICAgIHBhdGg6IHVyaSxcbiAgICAgIG1ldGhvZDogc2V0dGluZ3MubWV0aG9kLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGFnZW50OiBmYWxzZSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZSB8fCAndGV4dCdcblxuICAgIC8vIFJlc2V0IGVycm9yIGZsYWdcbiAgICBlcnJvckZsYWcgPSBmYWxzZVxuXG4gICAgLy8gSGFuZGxlIGFzeW5jIHJlcXVlc3RzXG4gICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAvLyBVc2UgdGhlIHByb3BlciBwcm90b2NvbFxuICAgICAgY29uc3QgZG9SZXF1ZXN0ID0gc3NsID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdFxuXG4gICAgICAvLyBSZXF1ZXN0IGlzIGJlaW5nIHNlbnQsIHNldCBzZW5kIGZsYWdcbiAgICAgIHNlbmRGbGFnID0gdHJ1ZVxuXG4gICAgICAvLyBBcyBwZXIgc3BlYywgdGhpcyBpcyBjYWxsZWQgaGVyZSBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJylcblxuICAgICAgLy8gSGFuZGxlciBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNwb25zZUhhbmRsZXIgKHJlc3ApIHtcbiAgICAgICAgLy8gU2V0IHJlc3BvbnNlIHZhciB0byB0aGUgcmVzcG9uc2Ugd2UgZ290IGJhY2tcbiAgICAgICAgLy8gVGhpcyBpcyBzbyBpdCByZW1haW5zIGFjY2Vzc2FibGUgb3V0c2lkZSB0aGlzIHNjb3BlXG4gICAgICAgIHJlc3BvbnNlID0gcmVzcFxuICAgICAgICAvLyBDaGVjayBmb3IgcmVkaXJlY3RcbiAgICAgICAgLy8gQFRPRE8gUHJldmVudCBsb29wZWQgcmVkaXJlY3RzXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMyB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDcpIHtcbiAgICAgICAgICAvLyBDaGFuZ2UgVVJMIHRvIHRoZSByZWRpcmVjdCBsb2NhdGlvblxuICAgICAgICAgIHNldHRpbmdzLnVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb25cbiAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVXJsLlVSTChzZXR0aW5ncy51cmwpXG4gICAgICAgICAgLy8gU2V0IGhvc3QgdmFyIGluIGNhc2UgaXQncyB1c2VkIGxhdGVyXG4gICAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZVxuICAgICAgICAgIC8vIE9wdGlvbnMgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB7XG4gICAgICAgICAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogdXJsLnBvcnQsXG4gICAgICAgICAgICBwYXRoOiB1cmwucGF0aCxcbiAgICAgICAgICAgIG1ldGhvZDogcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzID8gJ0dFVCcgOiBzZXR0aW5ncy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLndpdGhDcmVkZW50aWFsc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElzc3VlIHRoZSBuZXcgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3QgPSBkb1JlcXVlc3QobmV3T3B0aW9ucywgcmVzcG9uc2VIYW5kbGVyKS5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpXG4gICAgICAgICAgcmVxdWVzdC5lbmQoKVxuICAgICAgICAgIC8vIEBUT0RPIENoZWNrIGlmIGFuIFhIUiBldmVudCBuZWVkcyB0byBiZSBmaXJlZCBoZXJlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gJ3V0ZjgnIDogJ2JpbmFyeSdcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAgIH1cblxuICAgICAgICBzZXRTdGF0ZShzZWxmLkhFQURFUlNfUkVDRUlWRUQpXG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZVxuXG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSdzIHNvbWUgZGF0YVxuICAgICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ICs9IGNodW5rXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBlbWl0IHN0YXRlIGNoYW5nZXMgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkxPQURJTkcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgZW5kIGV2ZW50IGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWRcbiAgICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKVxuICAgICAgICAgICAgICBzZW5kRmxhZyA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlJ3Mgc29tZSBkYXRhXG4gICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2VCaW5hcnkucHVzaChjaHVuaylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IGVtaXQgc3RhdGUgY2hhbmdlcyBpZiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAgICAgICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuTE9BRElORylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGJ1ZmZlcnMgYXJlIFVpbnQ4QXJyYXkgaW5zdGFuY2VzXG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlID0gQnVmZmVyLmNvbmNhdChyZXNwb25zZUJpbmFyeSkuYnVmZmVyXG4gICAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgZW5kIGV2ZW50IGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWRcbiAgICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKVxuICAgICAgICAgICAgICBzZW5kRmxhZyA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IsIHVybClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gRXJyb3IgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3RcbiAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIGVycm9ySGFuZGxlciAoZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvciwgdXJsKVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBkb1JlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VIYW5kbGVyKS5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpXG5cbiAgICAgIC8vIE5vZGUgMC40IGFuZCBsYXRlciB3b24ndCBhY2NlcHQgZW1wdHkgZGF0YS4gTWFrZSBzdXJlIGl0J3MgbmVlZGVkLlxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmVxdWVzdC53cml0ZShkYXRhKVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmVuZCgpXG5cbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnbG9hZHN0YXJ0JylcbiAgICB9IGVsc2UgeyAvLyBTeW5jaHJvbm91c1xuICAgICAgY29uc3QgbWF4QnVmZmVyID0gcHJvY2Vzcy5lbnYuVU5YSFJfTUFYX0JVRkZFUlxuICAgICAgICA/IHBhcnNlSW50KHByb2Nlc3MuZW52LlVOWEhSX01BWF9CVUZGRVIpXG4gICAgICAgIDogREVGQVVMVF9NQVhfQlVGRkVSXG4gICAgICBjb25zdCBlbmNvZGluZyA9IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gJ3V0ZjgnIDogJ2JpbmFyeSdcbiAgICAgIGNvbnN0IHNjcmlwdFBhdGggPSBvc3BhdGguam9pbihfX2Rpcm5hbWUsICdyZXF1ZXN0LmpzJylcbiAgICAgIGNvbnN0IG91dHB1dCA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhgXCIke3Byb2Nlc3MuZXhlY1BhdGh9XCIgXCIke3NjcmlwdFBhdGh9XCIgXFxcbi0tc3NsPVwiJHtzc2x9XCIgXFxcbi0tZW5jb2Rpbmc9XCIke2VuY29kaW5nfVwiIFxcXG4tLXJlcXVlc3Qtb3B0aW9ucz0ke0pTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKX1gLCB7IHN0ZGlvOiBbJ3BpcGUnLCAncGlwZScsICdwaXBlJ10sIGlucHV0OiBkYXRhLCBtYXhCdWZmZXI6IG1heEJ1ZmZlciB9KVxuICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXRwdXQudG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdHJhbnNsYXRlRXJyb3IocmVzdWx0LmVycm9yLCB1cmwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZSA9IHJlc3VsdC5kYXRhXG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzdWx0LmRhdGEuc3RhdHVzQ29kZVxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgc2VsZi5yZXNwb25zZSA9IFVpbnQ4QXJyYXkuZnJvbShyZXN1bHQuZGF0YS5iaW5hcnkuZGF0YSkuYnVmZmVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSByZXN1bHQuZGF0YS50ZXh0XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB0byBkZWFsIHdpdGggaXQuXG4gICAqL1xuICB0aGlzLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCB1cmwpIHtcbiAgICB0aGlzLnN0YXR1cyA9IDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gJydcbiAgICBlcnJvckZsYWcgPSB0cnVlXG4gICAgc2V0U3RhdGUodGhpcy5ET05FKVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZXJyb3InLCB7IGVycm9yOiB0cmFuc2xhdGVFcnJvcihlcnJvciwgdXJsKSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIHJlcXVlc3QuXG4gICAqL1xuICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LmFib3J0KClcbiAgICAgIHJlcXVlc3QgPSBudWxsXG4gICAgfVxuXG4gICAgaGVhZGVycyA9IGRlZmF1bHRIZWFkZXJzXG4gICAgdGhpcy5zdGF0dXMgPSAwXG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSAnJ1xuICAgIHRoaXMucmVzcG9uc2VYTUwgPSAnJ1xuXG4gICAgZXJyb3JGbGFnID0gdHJ1ZVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5VTlNFTlQgJiZcbiAgICAgICh0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuT1BFTkVEIHx8IHNlbmRGbGFnKSAmJlxuICAgICAgdGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLkRPTkUpIHtcbiAgICAgIHNlbmRGbGFnID0gZmFsc2VcbiAgICAgIHNldFN0YXRlKHRoaXMuRE9ORSlcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlRcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Fib3J0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyLiBQcmVmZXJyZWQgbWV0aG9kIG9mIGJpbmRpbmcgdG8gZXZlbnRzLlxuICAgKi9cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGV2ZW50IGluIGxpc3RlbmVycykpIHtcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBbXVxuICAgIH1cbiAgICAvLyBDdXJyZW50bHkgYWxsb3dzIGR1cGxpY2F0ZSBjYWxsYmFja3MuIFNob3VsZCBpdD9cbiAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGNhbGxiYWNrIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZC5cbiAgICogT25seSB3b3JrcyBvbiB0aGUgbWF0Y2hpbmcgZnVuY2l0b24sIGNhbm5vdCBiZSBhIGNvcHkuXG4gICAqL1xuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGV2ZW50IGluIGxpc3RlbmVycykge1xuICAgICAgLy8gRmlsdGVyIHdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGggdGhlIGNhbGxiYWNrIHJlbW92ZWRcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnNbZXZlbnRdLmZpbHRlcihmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgcmV0dXJuIGV2ICE9PSBjYWxsYmFja1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggYW55IGV2ZW50cywgaW5jbHVkaW5nIGJvdGggXCJvblwiIG1ldGhvZHMgYW5kIGV2ZW50cyBhdHRhY2hlZCB1c2luZyBhZGRFdmVudExpc3RlbmVyLlxuICAgKi9cbiAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmWydvbicgKyBldmVudF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGZbJ29uJyArIGV2ZW50XShhcmdzKVxuICAgIH1cbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdW2ldLmNhbGwoc2VsZiwgYXJncylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyByZWFkeVN0YXRlIGFuZCBjYWxscyBvbnJlYWR5c3RhdGVjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIHtOdW1iZXJ9IE5ldyBzdGF0ZVxuICAgKi9cbiAgY29uc3Qgc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHNlbGYuTE9BRElORyB8fCBzZWxmLnJlYWR5U3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICBzZWxmLnJlYWR5U3RhdGUgPSBzdGF0ZVxuXG4gICAgICBpZiAoc2V0dGluZ3MuYXN5bmMgfHwgc2VsZi5yZWFkeVN0YXRlIDwgc2VsZi5PUEVORUQgfHwgc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyZWFkeXN0YXRlY2hhbmdlJylcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FICYmICFlcnJvckZsYWcpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdsb2FkJylcbiAgICAgICAgLy8gQFRPRE8gZmlndXJlIG91dCBJbnNwZWN0b3JJbnN0cnVtZW50YXRpb246OmRpZExvYWRYSFIoY29va2llKVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2xvYWRlbmQnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRyYW5zbGF0ZUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCB1cmwpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9URk9VTkQnIHx8IGVycm9yLmNvZGUgPT09ICdFQUlfQUdBSU4nKSB7XG4gICAgICAgIC8vIFhNTEh0dHBSZXF1ZXN0IHRocm93cyBhIERPTUV4Y2VwdGlvbiB3aGVuIEROUyBsb29rdXAgZmFpbHM6XG4gICAgICAgIC8vIGNvZGU6IDE5XG4gICAgICAgIC8vIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3NlbmQnIG9uICdYTUxIdHRwUmVxdWVzdCc6IEZhaWxlZCB0byBsb2FkICdodHRwOi8vdXJsLycuXCJcbiAgICAgICAgLy8gbmFtZTogXCJOZXR3b3JrRXJyb3JcIlxuICAgICAgICAvLyBzdGFjazogKC4uLilcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ3NlbmQnIG9uICdYTUxIdHRwUmVxdWVzdCc6IEZhaWxlZCB0byBsb2FkICcke3VybH0nLmApXG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3JcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyb3IpKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKGVycm9yKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/unxhr/lib/XMLHttpRequest.js\n");

/***/ })

};
;